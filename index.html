<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Shoryuken Practice</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
            background: #f5f5f5;
        }

        .card {
            background: white;
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            max-width: 420px;
            margin: auto;
        }

        h1 {
            font-size: 1.4rem;
            margin-bottom: 16px;
        }

        .counter {
            font-size: 2rem;
            font-weight: bold;
            margin: 12px 0;
        }

        .status {
            color: #444;
            margin-top: 4px;
        }

        .small {
            font-size: 0.9rem;
            color: #666;
        }

        .prev-count {
            font-size: 1rem;
            color: #888;
            margin-top: 4px;
        }

        .button-select {
            cursor: pointer;
            padding: 4px 8px;
            margin: 4px;
            border: 1px solid #ccc;
            border-radius: 6px;
            display: inline-block;
        }

        .button-select.active {
            background: #ddd;
        }

        .toggle-button {
            display: flex;
            align-items: center;
            position: relative;
            width: 100px;
            height: 50px;
            border-radius: 50px;
            box-sizing: content-box;
            background-color: #ff8d8d33;
            cursor: pointer;
            transition: background-color .4s;
        }

        .toggle-button:has(:checked) {
            background-color: #75bbff33;
        }

        .toggle-button::before {
            position: absolute;
            left: 5px;
            width: 42px;
            height: 42px;
            border-radius: 50%;
            background-color: #ff8d8d;
            content: '';
            transition: left .4s;
        }

        .toggle-button:has(:checked)::before {
            left: 50px;
            background-color: #75bbff;
        }

        .toggle-button::after {
            position: absolute;
            left: 26px;
            transform: translateX(-50%);
            color: #fff;
            font-weight: 600;
            font-size: .9em;
            content: '1P';
            transition: left .4s;
        }

        .toggle-button:has(:checked)::after {
            left: 71px;
            content: '2P';
        }

        .toggle-button input {
            display: none;
        }
    </style>
</head>

<body>
    <div class="card">
        <h1>昇竜拳練習 Shoryuken Practice</h1>
        <div>
            <p>昇竜拳用のボタン Your Buttons for Shoryuken</p>
            <div id="buttonSelectors">
                <span class="button-select" data-index="0">Button 0</span>
                <span class="button-select" data-index="1">Button 1</span>
                <span class="button-select" data-index="2">Button 5</span>
            </div>
            <input type="checkbox" id="resetOrNot" checked>失敗時リセット Whether to reset after a failure</input>
            <label class="toggle-button">
                <input type="checkbox" id="invertToggle" />
            </label>
            <p class="counter" id="count">0</p>
            <p class="prev-count" id="prevCount">前回のカウント Previous count：0</p>
            <input type="button" value="Back" id="back"></input>
            <input type="button" value="+" id="increase"></input>
            <input type="button" value="-" id="decrease"></input>
            <input type="button" value="Reset" id="reset"></input>
            <p class="status" id="status">コントローラーを接続してください Connect your controller</p>
        </div>
    </div>

    <script>
        let count = 0;
        let prevCountValue = 0;
        const DIR_UP = 12;
        const DIR_DOWN = 13;
        const DIR_LEFT = 14;
        const DIR_RIGHT = 15;
        const commands = [[3, 2, 3], [6, 2, 3], [6, 3, 6]];

        const inputHistory = Array(20).fill(5);
        let prevButtons = {};

        const targetButtons = [0, 1, 5];
        let activeSelectorIndex = null;
        let waitingForRelease = false;

        let render = true;
        let division = 5;
        let inverted = false;
        let divButton = [false, false, false];
        let resetOrNot = true;

        function activateSelector(index) {
            document.querySelectorAll('.button-select').forEach(e => e.classList.remove('active'));
            document.querySelector(`.button-select[data-index='${index}']`).classList.add('active');
            activeSelectorIndex = index;
        }

        document.getElementById('resetOrNot').addEventListener('change', e => {
            resetOrNot = !resetOrNot;
        });

        document.getElementById('back').addEventListener('click', e => {
            if (prevCountValue != 0) {
                count = prevCountValue;
                prevCountValue = 0;
                document.getElementById('count').textContent = count;
                document.getElementById('prevCount').textContent = '前回のカウント Previous count：' + prevCountValue;
            }
        });

        document.getElementById('increase').addEventListener('click', e => {
            count++;
            document.getElementById('count').textContent = count;
        });

        document.getElementById('decrease').addEventListener('click', e => {
            if (count != 0) {
                count--;
                document.getElementById('count').textContent = count;
            }
        });

        document.getElementById('reset').addEventListener('click', e => {
            if (count != 0) {
                prevCountValue = count;
                count = 0;
                document.getElementById('count').textContent = count;
                document.getElementById('prevCount').textContent = '前回のカウント Previous count：' + prevCountValue;
            }
        });

        document.querySelectorAll('.button-select').forEach(el => {
            el.addEventListener('click', () => {
                const index = parseInt(el.dataset.index);
                activateSelector(index);
            });
        });

        document.getElementById('invertToggle').addEventListener('change', e => {
            inverted = e.target.checked;
        });

        function getDirectionValue(up, down, left, right) {
            if (inverted) {
                let tmp = left;
                left = right;
                right = tmp;
            }
            if (up && left) return 7;
            if (up && right) return 9;
            if (down && left) return 1;
            if (down && right) return 3;
            if (up) return 8;
            if (down) return 2;
            if (left) return 4;
            if (right) return 6;
            return 5;
        }

        function checkSequence() {
            const len = inputHistory.length;
            for (let c = 0; c < commands.length; c++) {
                for (let i = len - 1; i >= Math.max(0, len - 7); i--) {
                    if (inputHistory[i] === commands[c][2]) {
                        for (let j = i - 1; j >= Math.max(0, i - 7); j--) {
                            if (inputHistory[j] === commands[c][1]) {
                                for (let k = j - 1; k >= Math.max(0, j - 7); k--) {
                                    if (inputHistory[k] === commands[c][0]) {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return false;
        }

        function loop() {
            setTimeout(function () {
                const pad = (navigator.getGamepads && navigator.getGamepads()[0]) || null;
                if (!pad) {
                    document.getElementById('status').textContent = 'コントローラーを接続してください Connect your controller';
                    return requestAnimationFrame(loop);
                } else {
                    document.getElementById('status').textContent = 'コントローラー接続中 Conected the controller：' + pad.id;
                }

                const now = {};
                pad.buttons.forEach((btn, i) => { now[i] = btn.pressed; });

                if (activeSelectorIndex !== null && !waitingForRelease) {
                    for (let i = 0; i < pad.buttons.length; i++) {
                        if (now[i]) {
                            // もし他の登録済みのボタンに割り当てられていたら解除
                            for (let j = 0; j < targetButtons.length; j++) {
                                if (j !== activeSelectorIndex && targetButtons[j] === i) {
                                    targetButtons[j] = null;
                                    document.querySelector(`.button-select[data-index='${j}']`).textContent = '未登録';
                                }
                            }
                            if (targetButtons[activeSelectorIndex] === i) {
                                targetButtons[activeSelectorIndex] = null;
                                document.querySelector(`.button-select[data-index='${activeSelectorIndex}']`).textContent = '未登録';
                            } else {
                                targetButtons[activeSelectorIndex] = i;
                                document.querySelector(`.button-select[data-index='${activeSelectorIndex}']`).textContent = 'Button ' + i;
                            }
                            waitingForRelease = true;
                            break;
                        }
                    }
                }

                if (render) {
                    if (waitingForRelease) {
                        const anyPressed = Object.values(now).some(v => v);
                        if (!anyPressed) {
                            waitingForRelease = false;
                            if (activeSelectorIndex !== null && activeSelectorIndex < 2) {
                                activateSelector(activeSelectorIndex + 1);
                            } else {
                                document.querySelectorAll('.button-select').forEach(e => e.classList.remove('active'));
                                activeSelectorIndex = null;
                            }
                        }
                    }

                    let dirVal = getDirectionValue(now[DIR_UP], now[DIR_DOWN], now[DIR_LEFT], now[DIR_RIGHT]);
                    if (inputHistory[inputHistory.length - 1] === dirVal && dirVal != division && dirVal != 5) {
                        dirVal = division;
                    }
                    inputHistory.shift();
                    inputHistory.push(dirVal);

                    for (let i = 0; i < targetButtons.length; i++) {
                        idx = targetButtons[i];
                        if (idx !== null && (now[idx] || divButton[i]) && !prevButtons[idx]) {
                            if (checkSequence()) {
                                count++;
                            } else {
                                if (count != 0 && resetOrNot) {
                                    prevCountValue = count;
                                    count = 0;
                                }
                            }
                            document.getElementById('count').textContent = count;
                            document.getElementById('prevCount').textContent = '前回のカウント Previous count：' + prevCountValue;
                        }
                    }
                    prevButtons = { ...now };
                } else {
                    division = getDirectionValue(now[DIR_UP], now[DIR_DOWN], now[DIR_LEFT], now[DIR_RIGHT]);
                    for (let i = 0; i < targetButtons.length; i++) {
                        idx = targetButtons[i];
                        if (idx !== null && now[idx] && !prevButtons[idx]) {
                            divButton[i] = true;
                        } else {
                            divButton[i] = false;
                        }
                    }
                }
                render = !render;

                requestAnimationFrame(loop);
            }, 1000 / 120);
        }

        // requestAnimationFrame(loop);
        loop();
    </script>
</body>

</html>
